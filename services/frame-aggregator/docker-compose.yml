# ============================================================================
# Frame Aggregator Service - Metadata Consolidation Microservice
# ============================================================================
#
# PURPOSE:
#   Consolidates results from multiple vision services (OCR, Detection, Captioning)
#   into unified frame metadata. Acts as the central coordination point for
#   combining parallel processing results before downstream analysis.
#
# ROLE IN VIDEO RAG PIPELINE:
#   Input:  Multiple topics (ocr-results, detection-results, caption-results)
#   Process: Correlation and aggregation of vision service outputs
#   Output: aggregated-frame-metadata topic (unified frame analysis)
#
# PROCESSING WORKFLOW:
#   1. Consume messages from multiple input topics simultaneously
#   2. Correlate results by frame_id across different vision services
#   3. Wait for all expected results or timeout threshold
#   4. Merge OCR text, detected objects, and captions into unified structure
#   5. Add temporal and spatial correlation metadata
#   6. Publish consolidated results to aggregated-frame-metadata topic
#
# AGGREGATION CAPABILITIES:
#   - Multi-topic message correlation by frame identifier
#   - Timeout-based partial aggregation for missing results
#   - Spatial relationship analysis between detected objects and text
#   - Confidence score normalization across different models
#   - Metadata enrichment with processing timestamps
#
# CORRELATION STRATEGY:
#   - Primary key: frame_id (UUID) for exact matching
#   - Timeout window: 30 seconds for complete result collection
#   - Partial results: Publish incomplete aggregations after timeout
#   - Quality scoring: Combined confidence metrics from all services
#
# OUTPUT FORMAT:
#   {
#     "frame_id": "uuid",
#     "service": "frame-aggregator",
#     "timestamp": 1234567890.123,
#     "aggregated_results": {
#       "ocr": { "text": "...", "confidence": 0.95, "bounding_boxes": [...] },
#       "detection": { "objects": [...], "detection_count": 3 },
#       "caption": { "description": "...", "confidence": 0.92 },
#       "spatial_relationships": [...],
#       "overall_confidence": 0.89
#     },
#     "processing_metadata": {
#       "aggregation_time_ms": 45.2,
#       "services_completed": ["ocr", "detection", "caption"],
#       "services_timeout": [],
#       "correlation_quality": "complete"
#     }
#   }
#
# PERFORMANCE CHARACTERISTICS:
#   - Low latency aggregation (~50ms processing time)
#   - Memory-efficient correlation using in-memory cache
#   - Concurrent processing of multiple frame aggregations
#   - Automatic cleanup of expired correlation entries
#
# DEPENDENCIES:
#   - Kafka cluster (healthy)
#   - All upstream vision services (OCR, Detection, Captioning)
#   - Redis cache for correlation state (optional)
#
# MONITORING:
#   - Health endpoint: http://localhost:8004/health
#   - Aggregation metrics: completion rates, timeout rates
#   - Correlation quality metrics and processing latency
#
# ============================================================================

version: '3.8'

services:
  frame-aggregator:
    # Build from local Dockerfile with aggregation logic
    build:
      context: . # Current service directory
      dockerfile: Dockerfile

    container_name: ${FRAME_AGGREGATOR_CONTAINER_NAME}
    hostname: frame-aggregator # Fixed hostname for service discovery
    
    # OrbStack will automatically create: frame-aggregator.video-rag.orb.local

    # Port mapping for health checks and debugging
    ports:
      # HTTP API for health checks and aggregation status
      - "${FRAME_AGGREGATOR_HOST_PORT}:${FRAME_AGGREGATOR_INTERNAL_PORT}" # 8004:8000

    # Service configuration via environment variables
    environment:
      # Kafka connection configuration
      - KAFKA_BOOTSTRAP_SERVERS=${KAFKA_BOOTSTRAP_SERVERS} # kafka:9092

      # Multiple input topics for vision service results
      # Comma-separated list for parallel consumption
      - KAFKA_INPUT_TOPICS=${KAFKA_TOPIC_OCR_RESULTS},${KAFKA_TOPIC_DETECTION_RESULTS},${KAFKA_TOPIC_CAPTION_RESULTS}

      # Output topic for aggregated metadata
      - KAFKA_OUTPUT_TOPIC=${KAFKA_TOPIC_AGGREGATED_METADATA} # aggregated-frame-metadata

      # Consumer group for load balancing and fault tolerance
      - KAFKA_CONSUMER_GROUP=${FRAME_AGGREGATOR_CONSUMER_GROUP} # frame-aggregator-group

      # Service identification
      - SERVICE_NAME=${FRAME_AGGREGATOR_SERVICE_NAME} # frame-aggregator

      # Aggregation configuration
      - AGGREGATION_TIMEOUT_SECONDS=${AGGREGATION_TIMEOUT_SECONDS} # 30
      - MAX_CORRELATION_CACHE_SIZE=${MAX_CORRELATION_CACHE_SIZE} # 10000

      # Logging configuration
      - LOG_LEVEL=${LOG_LEVEL} # INFO/DEBUG

    # Note: Kafka dependency managed by infrastructure startup order

    # Production resource management
    deploy:
      resources:
        # Resource limits to prevent system overload
        limits:
          memory: 512M # Maximum memory for aggregation operations
          cpus: '0.5' # Maximum CPU cores for correlation processing
        # Resource reservations for guaranteed performance
        reservations:
          memory: 256M # Guaranteed memory for correlation cache
          cpus: '0.25' # Guaranteed CPU for consistent processing

    # Enterprise security configuration
    security_opt:
      # Prevent privilege escalation attacks
      - no-new-privileges:true
    
    # Production logging configuration
    logging:
      driver: "json-file"
      options:
        # Log rotation to prevent disk space issues
        max-size: "10m" # Maximum log file size
        max-file: "3" # Number of rotated log files to keep
        # Structured logging for centralized log aggregation
        labels: "service=frame-aggregator,environment=production,component=data-aggregation"

    # Network configuration
    networks:
      - ${NETWORK_NAME} # video-rag-network bridge

    # Production restart policy
    restart: unless-stopped

    # Optional health check configuration
    healthcheck:
      # Test aggregator API availability and correlation cache status
      test: ["CMD", "curl", "-f", "http://localhost:${FRAME_AGGREGATOR_INTERNAL_PORT}/health"]
      
      # Health check intervals
      interval: 30s # Check every 30 seconds
      timeout: 5s # Wait up to 5 seconds for response
      retries: 3 # Retry 3 times before marking unhealthy
      start_period: 15s # Allow time for service initialization

# Network reference - managed by infrastructure
networks:
  video-rag-network:
    name: ${NETWORK_NAME}
    external: true # Network created by infrastructure services