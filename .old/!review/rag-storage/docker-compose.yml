version: '3.8'

# ============================================================================
# RAG Storage Service - Vector Database Integration
# ============================================================================
#
# PURPOSE:
#   Final stage of Video RAG pipeline. Stores processed video segments with
#   embeddings in Qdrant vector database for semantic search and retrieval.
#   Enables RAG queries over video content using similarity search.
#
# ROLE IN VIDEO RAG PIPELINE:
#   Input:  video-segments topic (processed segments with metadata)
#   Process: Vector embedding generation and Qdrant storage
#   Output: Searchable vector database for RAG applications
#
# PROCESSING WORKFLOW:
#   1. Consume segment messages from Kafka 'video-segments' topic
#   2. Generate embeddings using sentence transformers
#   3. Store vectors and metadata in Qdrant collections
#   4. Index for fast similarity search
#   5. Provide query API for RAG applications
#
# STORAGE CAPABILITIES:
#   - Vector embeddings for semantic search
#   - Metadata storage (timestamps, captions, objects)
#   - Hybrid search (vector + metadata filtering)
#   - Real-time indexing and retrieval
#   - Scalable collection management
#
# VECTOR COLLECTIONS:
#   - video_segments: Main collection for processed segments
#   - frame_embeddings: Individual frame-level vectors
#   - text_embeddings: OCR and caption embeddings
#   - Combined multimodal embeddings
#
# PERFORMANCE CHARACTERISTICS:
#   - CPU-based processing (no GPU required)
#   - Sub-millisecond query response times
#   - Concurrent read/write operations
#   - Memory usage: ~1-2GB (depends on collection size)
#   - Horizontal scaling support
#
# QUERY CAPABILITIES:
#   - Semantic similarity search
#   - Temporal range filtering
#   - Metadata-based filtering
#   - Batch query processing
#   - Real-time updates
#
# DEPENDENCIES:
#   - Kafka cluster (healthy)
#   - Qdrant vector database (healthy)
#   - Sentence transformers for embeddings
#   - No GPU required (CPU-based embeddings)
#
# MONITORING:
#   - Health endpoint: http://localhost:8010/health
#   - Vector storage metrics and query performance
#   - Qdrant connection status and collection stats
#
# ============================================================================

services:
  rag-storage:
    # Build from local Dockerfile with Qdrant and embedding dependencies
    build:
      context: .  # Current service directory
      dockerfile: Dockerfile
    
    container_name: ${RAG_STORAGE_CONTAINER_NAME}
    hostname: rag-storage  # Fixed hostname for service discovery
    
    # Port mapping for health checks and query API
    ports:
      # HTTP API for health checks and RAG query interface
      - "${RAG_STORAGE_HOST_PORT}:${RAG_STORAGE_INTERNAL_PORT}"  # 8010:8000
    
    # Service configuration via environment variables
    environment:
      # Kafka connection configuration
      - KAFKA_BOOTSTRAP_SERVERS=${KAFKA_BOOTSTRAP_SERVERS}  # kafka:9092
      
      # Input topic for processed video segments
      - KAFKA_INPUT_TOPIC=${KAFKA_TOPIC_VIDEO_SEGMENTS}     # video-segments
      
      # Consumer group for segment processing
      - KAFKA_CONSUMER_GROUP=${RAG_STORAGE_CONSUMER_GROUP}  # rag-storage-group
      
      # Service identification
      - SERVICE_NAME=${RAG_STORAGE_NAME}                    # rag-storage
      
      # Logging configuration
      - LOG_LEVEL=${LOG_LEVEL}                              # INFO/DEBUG
      
      # Qdrant vector database connection
      - QDRANT_URL=http://qdrant:${QDRANT_REST_PORT}       # http://qdrant:6333
      
      # Default collection name for video segments
      - QDRANT_COLLECTION=${QDRANT_COLLECTION}              # video_segments
    
    # Dependency management - wait for both Kafka and Qdrant
    depends_on:
      kafka:
        condition: service_healthy  # Ensures Kafka is operational
      qdrant:
        condition: service_healthy  # Ensures Qdrant is ready for connections
    
    # Network configuration
    networks:
      - ${NETWORK_NAME}  # video-rag-network bridge
    
    # Restart policy
    restart: unless-stopped
    
    # Note: No GPU allocation needed - CPU-based embedding generation
    # Sentence transformers can run efficiently on CPU for this use case

# Network reference - managed by infrastructure
networks:
  video-rag-network:
    name: ${NETWORK_NAME}
    external: true  # Network created by infrastructure services
